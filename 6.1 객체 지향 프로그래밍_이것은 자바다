6.1 객체 지향 프로그래밍

-> 객체를 먼저 만들고, 하나씩 조립해서 완성된 프로그램을 만드는 것.

 

필드(field) : 속성

메소드(method) : 동작, 기능

 

* 객체 모델링 -> 현실세계의 객체를 소프트웨어 객체로 구현

 

객체 지향 프로그래밍의 특징

1. 캡슐화 : 객체의 필드, 메소드를 하나로 묶고 실제 구현 내용을 감추는 것

2. 상속

3. 다형성 : ex) 부모 클래스 , 인터페이스 타입 변환 허용

 

클래스(설계도)

 

인스턴스화 : 클래스로부터 객체를 만드는 과정

 

클래스 선언

* 주의할점 : 파일 이름과 동일한 클래스 선언에만 public 접근 제한자를 붙일 수 있다.

아니면 컴파일에러남

 

클래스 구성 맴버

1. 필드(field) : 객체의 데이터가 저장되는 곳, 선언 위치 상관없음

2. 생성자(Construtor) : 객체 생성 시 초기화 역할 담당, 메소드와 비슷하나 클래스 이름으로 되어 있고 리턴 타입이 없다! ex) new 연산자로 호출되는 {} 블럭

3. 메소드(method) : 객체의 동작에 해당하는 실행 블록

 

 

* 필드(field) -> 타입은 필드 저장 데이터 종류 :　기본타입(byte, short, int , long, float, doble, boolean) 과 참조타입(배열, 클래스, 인터페이스 ) 모두 올 수 있다.

필드의 초기값 : 선언시 주어질 수도 생략할 수도 있음

 

변수와　필드 차이점 : 변수는 자신이 선언된 생성자 또는 메소드 블록 내부에서만 사용, 필드는 생성자와 모든 메소드에서 사용(new 연산자 사용)

 

 

* 생성자(Construtor) : 생성자를 실행시키지 않고는 클래스로부터 객체를 만들 수 없다!

new 연산자에 의해 생성자가 성공적으로 실행되면 힙(heap) 영역에 객체가 생성되고 객체의 주소가 리턴된다.

 

기본생성자 -> 모든 클래스는 생성자가 반드시 존재하며, 하나 이상을 가질 수 있다.

public class로 선언되면 기본생성자도 public

class로만 선언되면, 기본생성자에도 public 없이 선언

 

예를 들어, 3개의 매개값을 생성자가 받기 위해서는 다음과 같이 생성자 선언

public class Car{

//생성자

Car(String model, String color, int maxSpeed) {...}

}

 

필드 초기화

1. 필드 초기화

2. 생성자 초기화 : 외부에서 다양한 값들로 초기화될 때 사용

 

public koran(String name, String ssn) {

this.name(필드) = name; (매개변수)

this.ssn(필드) = ssn; (매개변수)

}

 

* 생성자 오버로딩

: 매개변수 타입과 개수 , 선언된 순서가 똑같을 경우 매개 변수 이름만 바꾸는 것은 오버로딩이 아니다.

 

* 메소드

중괄호{} 메소드는 
